#!/bin/bash

VERSION="1.2.0"
LOG_DIR="/var/log/restoremysql"
FORCE_LOG=false

show_help() {
  cat <<EOF
Uso:
  restoremysql              Ejecuta el restaurador interactivo de bases MySQL
  restoremysql --log        Guarda logs de todas las restauraciones (éxito o error)
  restoremysql --help       Muestra esta ayuda
  restoremysql --version    Muestra la versión

Notas:
  - Requiere los comandos 'mysql' y 'pv'
  - Los archivos .sql deben existir en la ruta actual o completa
  - Los logs se almacenan en: $LOG_DIR
EOF
}

# Parse flags
for arg in "$@"; do
  case "$arg" in
    --help|-h)
      show_help
      exit 0
      ;;
    --version|-v)
      echo "restoremysql v$VERSION"
      exit 0
      ;;
    --log)
      FORCE_LOG=true
      ;;
  esac
done

# Verificar dependencias
for cmd in mysql pv; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "[ERROR] El comando '$cmd' no está instalado."
    echo "Instálalo con: sudo apt install $cmd"
    exit 1
  fi
done

# Crear carpeta de logs si no existe
if [ ! -d "$LOG_DIR" ]; then
  sudo mkdir -p "$LOG_DIR"
  sudo chown "$USER":"$USER" "$LOG_DIR"
fi

echo "=== RESTAURADOR DE RESPALDOS MySQL ==="
echo

read -p "Usuario MySQL: " DB_USER
read -s -p "Contraseña MySQL: " DB_PASS
echo

declare -a BASES
declare -a ARCHIVOS
declare -a EXITOSAS
declare -a FALLIDAS

while true; do
  read -p "Nombre de la base de datos a restaurar: " DB_NAME
  read -e -p "Ruta al archivo SQL de respaldo: " FILE_PATH

  if [ ! -f "$FILE_PATH" ]; then
    echo ">>> Archivo no encontrado: $FILE_PATH"
    continue
  fi

  BASES+=("$DB_NAME")
  ARCHIVOS+=("$FILE_PATH")

  read -p "¿Deseas cargar otro respaldo? (s/n): " continuar
  [[ "$continuar" =~ ^[Ss]$ ]] || break
done

LOGFILE="$LOG_DIR/restore_$(date +%Y%m%d_%H%M%S).log"
global_start=$(date +%s)

show_progress() {
  local file="$1"
  local db="$2"
  local tmpfile=$(mktemp)

  echo ">>> Restaurando '$db' desde '$file'..."
  local start_time=$(date +%s)

  mysql -u "$DB_USER" -p"$DB_PASS" -e "CREATE DATABASE IF NOT EXISTS \`$db\`;" 2>>"$tmpfile"

  (
    pv -n "$file" | mysql -u "$DB_USER" -p"$DB_PASS" "$db"
  ) 2>>"$tmpfile" | {
    spin='-\|/'
    i=0
    while read -r percent; do
      i=$(( (i+1) %4 ))
      bar_width=40
      filled=$((percent * bar_width / 100))
      empty=$((bar_width - filled))
      bar=$(printf "%${filled}s" | tr ' ' '#')$(printf "%${empty}s" | tr ' ' '-')
      printf "\r[%s] %3d%% [%s]" "${spin:$i:1}" "$percent" "$bar"
    done
    echo -ne "\r\033[K"
  }

  local end_time=$(date +%s)
  local duration=$((end_time - start_time))

  if [ -s "$tmpfile" ]; then
    echo ">>> [ERROR] Fallo al restaurar '$db'. Ver log en: $LOGFILE"
    FALLIDAS+=("$db")
    {
      echo "[$(date)] ERROR restaurando '$db' desde '$file'"
      cat "$tmpfile"
      echo "-----------------------------------------------"
    } >> "$LOGFILE"
  else
    echo ">>> Restauración completada para '$db' en ${duration}s."
    EXITOSAS+=("$db")
    if [ "$FORCE_LOG" = true ]; then
      {
        echo "[$(date)] ÉXITO restaurando '$db' desde '$file' en ${duration}s"
        echo "-----------------------------------------------"
      } >> "$LOGFILE"
    fi
  fi

  rm -f "$tmpfile"
}

for index in "${!BASES[@]}"; do
  show_progress "${ARCHIVOS[$index]}" "${BASES[$index]}"
done

global_end=$(date +%s)
global_duration=$((global_end - global_start))

echo
echo "=== RESUMEN FINAL ==="
echo "  Restauraciones exitosas: ${#EXITOSAS[@]}"
for db in "${EXITOSAS[@]}"; do echo "    - $db"; done

echo "  Restauraciones con error: ${#FALLIDAS[@]}"
for db in "${FALLIDAS[@]}"; do echo "    - $db"; done

echo "  Tiempo total: ${global_duration}s"
[[ "${#FALLIDAS[@]}" -gt 0 ]] && echo "  [!] Revisa el log: $LOGFILE"
echo "========================="

